{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { PLATFORM_ID, Injectable, Inject, Directive, Input, NgModule } from '@angular/core';\nimport { Subject, of, fromEvent } from 'rxjs';\nimport { takeUntil, filter, map, mergeMap, debounceTime } from 'rxjs/operators';\nimport { isPlatformBrowser } from '@angular/common';\n\nclass BrowserWindowRef {\n  constructor(platformId) {\n    this.platformId = platformId;\n  }\n\n  get nativeWindow() {\n    if (isPlatformBrowser(this.platformId)) {\n      return this.windowRef();\n    }\n\n    return false;\n  }\n\n  windowRef() {\n    // return the global native browser window object\n    return window;\n  }\n\n}\n\nBrowserWindowRef.ɵfac = function BrowserWindowRef_Factory(t) {\n  return new (t || BrowserWindowRef)(i0.ɵɵinject(PLATFORM_ID));\n};\n\nBrowserWindowRef.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: BrowserWindowRef,\n  factory: BrowserWindowRef.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(BrowserWindowRef, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\n\nclass ParallaxDirective {\n  constructor(hostElement, renderer, wr) {\n    this.hostElement = hostElement;\n    this.renderer = renderer;\n    this.wr = wr;\n    this.speed = 30;\n    this.axe = 'y';\n    this.property = 'transform';\n    this.propertyValue = 'translate3d';\n    this.active = true;\n    this.inViewport = true;\n    this.componentDestroy$ = new Subject();\n  }\n\n  ngAfterViewInit() {\n    this.element = this.hostElement.nativeElement;\n\n    if (this.element && this.wr.nativeWindow && !this.observer) {\n      this.initParallax();\n    }\n  }\n\n  initParallax() {\n    this.observer = this.createObserver(0);\n    this.observer.observe(this.element);\n    const parallax$ = of('').pipe(takeUntil(this.componentDestroy$), filter(() => this.active && this.inViewport), map(() => {\n      const coef = this.calculateCoef();\n      this.renderParallax(coef);\n      return coef;\n    }));\n    this.windowScroll$ = fromEvent(this.wr.nativeWindow, 'scroll').pipe(mergeMap(() => parallax$));\n    this.windowResize$ = fromEvent(this.wr.nativeWindow, 'resize').pipe(debounceTime(500), mergeMap(() => parallax$));\n  }\n\n  startParallax() {\n    this.inViewport = true;\n\n    if (this.wr.nativeWindow && this.initialPosition === undefined) {\n      this.initialPosition = this.wr.nativeWindow.pageYOffset;\n      this.windowScroll$.subscribe();\n      this.windowResize$.subscribe();\n    }\n  }\n\n  destroyParallax() {\n    this.inViewport = false;\n  }\n\n  calculateCoef() {\n    return (this.wr.nativeWindow.pageYOffset - this.initialPosition) * (this.speed / 100);\n  }\n\n  renderParallax(coef) {\n    this.renderer.setStyle(this.element, this.property, this.getPropertyValue(coef));\n  }\n\n  getPropertyValue(coef) {\n    let result = `${coef}px`;\n\n    if (this.property === 'transform') {\n      switch (this.propertyValue) {\n        case 'translate3d':\n          result = `translate3d(${this.getAxe(coef)})`;\n          break;\n\n        case 'scale':\n          result = `scale(${coef})`;\n          break;\n\n        case 'rotate':\n          result = `rotate(${coef}deg)`;\n          break;\n      }\n    }\n\n    switch (this.property) {\n      case 'opacity':\n        result = `${coef}`;\n        break;\n    }\n\n    return result;\n  }\n\n  getAxe(coef) {\n    let axe = [0, coef, 0];\n\n    if (this.axe === 'x') {\n      axe = [coef, 0, 0];\n    } else if (this.axe === 'z') {\n      axe = [0, 0, coef];\n    }\n\n    return `${axe[0]}px, ${axe[1]}px, ${axe[2]}px`;\n  }\n\n  createObserver(pourcent) {\n    const options = {\n      rootMargin: '0px',\n      threshold: pourcent / 100\n    };\n\n    const isIntersecting = entry => entry.isIntersecting || entry.intersectionRatio > 0;\n\n    return new IntersectionObserver((entries, observer) => {\n      entries.forEach(entry => {\n        if (isIntersecting(entry)) {\n          this.startParallax();\n        } else {\n          this.destroyParallax();\n        }\n      });\n    }, options);\n  }\n\n  ngOnDestroy() {\n    this.componentDestroy$.next(false);\n    this.componentDestroy$.complete();\n\n    if (this.wr.nativeWindow) {\n      this.observer.disconnect();\n    }\n  }\n\n}\n\nParallaxDirective.ɵfac = function ParallaxDirective_Factory(t) {\n  return new (t || ParallaxDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(BrowserWindowRef));\n};\n\nParallaxDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: ParallaxDirective,\n  selectors: [[\"\", \"ngx-parallax\", \"\"]],\n  inputs: {\n    speed: \"speed\",\n    axe: \"axe\",\n    property: \"property\",\n    propertyValue: \"propertyValue\",\n    active: \"active\"\n  }\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ParallaxDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngx-parallax]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: i0.Renderer2\n    }, {\n      type: BrowserWindowRef\n    }];\n  }, {\n    speed: [{\n      type: Input\n    }],\n    axe: [{\n      type: Input\n    }],\n    property: [{\n      type: Input\n    }],\n    propertyValue: [{\n      type: Input\n    }],\n    active: [{\n      type: Input\n    }]\n  });\n})();\n\nclass NgxParallaxModule {}\n\nNgxParallaxModule.ɵfac = function NgxParallaxModule_Factory(t) {\n  return new (t || NgxParallaxModule)();\n};\n\nNgxParallaxModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxParallaxModule\n});\nNgxParallaxModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxParallaxModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [ParallaxDirective],\n      imports: [],\n      exports: [ParallaxDirective]\n    }]\n  }], null, null);\n})();\n/*\n * Public API Surface of ngx-parallax\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NgxParallaxModule, ParallaxDirective };","map":{"version":3,"sources":["/Applications/MAMP/htdocs/npm/npm-directives/dist/ngx-parallax/fesm2015/yoozly-ngx-parallax.mjs"],"names":["i0","PLATFORM_ID","Injectable","Inject","Directive","Input","NgModule","Subject","of","fromEvent","takeUntil","filter","map","mergeMap","debounceTime","isPlatformBrowser","BrowserWindowRef","constructor","platformId","nativeWindow","windowRef","window","ɵfac","ɵprov","type","args","providedIn","undefined","decorators","ParallaxDirective","hostElement","renderer","wr","speed","axe","property","propertyValue","active","inViewport","componentDestroy$","ngAfterViewInit","element","nativeElement","observer","initParallax","createObserver","observe","parallax$","pipe","coef","calculateCoef","renderParallax","windowScroll$","windowResize$","startParallax","initialPosition","pageYOffset","subscribe","destroyParallax","setStyle","getPropertyValue","result","getAxe","pourcent","options","rootMargin","threshold","isIntersecting","entry","intersectionRatio","IntersectionObserver","entries","forEach","ngOnDestroy","next","complete","disconnect","ElementRef","Renderer2","ɵdir","selector","NgxParallaxModule","ɵmod","ɵinj","declarations","imports","exports"],"mappings":"AAAA,OAAO,KAAKA,EAAZ,MAAoB,eAApB;AACA,SAASC,WAAT,EAAsBC,UAAtB,EAAkCC,MAAlC,EAA0CC,SAA1C,EAAqDC,KAArD,EAA4DC,QAA5D,QAA4E,eAA5E;AACA,SAASC,OAAT,EAAkBC,EAAlB,EAAsBC,SAAtB,QAAuC,MAAvC;AACA,SAASC,SAAT,EAAoBC,MAApB,EAA4BC,GAA5B,EAAiCC,QAAjC,EAA2CC,YAA3C,QAA+D,gBAA/D;AACA,SAASC,iBAAT,QAAkC,iBAAlC;;AAEA,MAAMC,gBAAN,CAAuB;AACnBC,EAAAA,WAAW,CAACC,UAAD,EAAa;AACpB,SAAKA,UAAL,GAAkBA,UAAlB;AACH;;AACe,MAAZC,YAAY,GAAG;AACf,QAAIJ,iBAAiB,CAAC,KAAKG,UAAN,CAArB,EAAwC;AACpC,aAAO,KAAKE,SAAL,EAAP;AACH;;AACD,WAAO,KAAP;AACH;;AACDA,EAAAA,SAAS,GAAG;AACR;AACA,WAAOC,MAAP;AACH;;AAbkB;;AAevBL,gBAAgB,CAACM,IAAjB;AAAA,mBAA6GN,gBAA7G,EAAmGhB,EAAnG,UAA+IC,WAA/I;AAAA;;AACAe,gBAAgB,CAACO,KAAjB,kBADmGvB,EACnG;AAAA,SAAiHgB,gBAAjH;AAAA,WAAiHA,gBAAjH;AAAA,cAA+I;AAA/I;;AACA;AAAA,qDAFmGhB,EAEnG,mBAA2FgB,gBAA3F,EAAyH,CAAC;AAC9GQ,IAAAA,IAAI,EAAEtB,UADwG;AAE9GuB,IAAAA,IAAI,EAAE,CAAC;AAAEC,MAAAA,UAAU,EAAE;AAAd,KAAD;AAFwG,GAAD,CAAzH,EAG4B,YAAY;AAChC,WAAO,CAAC;AAAEF,MAAAA,IAAI,EAAEG,SAAR;AAAmBC,MAAAA,UAAU,EAAE,CAAC;AACxBJ,QAAAA,IAAI,EAAErB,MADkB;AAExBsB,QAAAA,IAAI,EAAE,CAACxB,WAAD;AAFkB,OAAD;AAA/B,KAAD,CAAP;AAIH,GARL;AAAA;;AAUA,MAAM4B,iBAAN,CAAwB;AACpBZ,EAAAA,WAAW,CAACa,WAAD,EAAcC,QAAd,EAAwBC,EAAxB,EAA4B;AACnC,SAAKF,WAAL,GAAmBA,WAAnB;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKC,EAAL,GAAUA,EAAV;AACA,SAAKC,KAAL,GAAa,EAAb;AACA,SAAKC,GAAL,GAAW,GAAX;AACA,SAAKC,QAAL,GAAgB,WAAhB;AACA,SAAKC,aAAL,GAAqB,aAArB;AACA,SAAKC,MAAL,GAAc,IAAd;AACA,SAAKC,UAAL,GAAkB,IAAlB;AACA,SAAKC,iBAAL,GAAyB,IAAIhC,OAAJ,EAAzB;AACH;;AACDiC,EAAAA,eAAe,GAAG;AACd,SAAKC,OAAL,GAAe,KAAKX,WAAL,CAAiBY,aAAhC;;AACA,QAAI,KAAKD,OAAL,IAAgB,KAAKT,EAAL,CAAQb,YAAxB,IAAwC,CAAC,KAAKwB,QAAlD,EAA4D;AACxD,WAAKC,YAAL;AACH;AACJ;;AACDA,EAAAA,YAAY,GAAG;AACX,SAAKD,QAAL,GAAgB,KAAKE,cAAL,CAAoB,CAApB,CAAhB;AACA,SAAKF,QAAL,CAAcG,OAAd,CAAsB,KAAKL,OAA3B;AACA,UAAMM,SAAS,GAAGvC,EAAE,CAAC,EAAD,CAAF,CAAOwC,IAAP,CAAYtC,SAAS,CAAC,KAAK6B,iBAAN,CAArB,EAA+C5B,MAAM,CAAC,MAAM,KAAK0B,MAAL,IAAe,KAAKC,UAA3B,CAArD,EAA6F1B,GAAG,CAAC,MAAM;AACrH,YAAMqC,IAAI,GAAG,KAAKC,aAAL,EAAb;AACA,WAAKC,cAAL,CAAoBF,IAApB;AACA,aAAOA,IAAP;AACH,KAJiH,CAAhG,CAAlB;AAKA,SAAKG,aAAL,GAAqB3C,SAAS,CAAC,KAAKuB,EAAL,CAAQb,YAAT,EAAuB,QAAvB,CAAT,CAA0C6B,IAA1C,CAA+CnC,QAAQ,CAAC,MAAMkC,SAAP,CAAvD,CAArB;AACA,SAAKM,aAAL,GAAqB5C,SAAS,CAAC,KAAKuB,EAAL,CAAQb,YAAT,EAAuB,QAAvB,CAAT,CAA0C6B,IAA1C,CAA+ClC,YAAY,CAAC,GAAD,CAA3D,EAAkED,QAAQ,CAAC,MAAMkC,SAAP,CAA1E,CAArB;AACH;;AACDO,EAAAA,aAAa,GAAG;AACZ,SAAKhB,UAAL,GAAkB,IAAlB;;AACA,QAAI,KAAKN,EAAL,CAAQb,YAAR,IAAwB,KAAKoC,eAAL,KAAyB5B,SAArD,EAAgE;AAC5D,WAAK4B,eAAL,GAAuB,KAAKvB,EAAL,CAAQb,YAAR,CAAqBqC,WAA5C;AACA,WAAKJ,aAAL,CAAmBK,SAAnB;AACA,WAAKJ,aAAL,CAAmBI,SAAnB;AACH;AACJ;;AACDC,EAAAA,eAAe,GAAG;AACd,SAAKpB,UAAL,GAAkB,KAAlB;AACH;;AACDY,EAAAA,aAAa,GAAG;AACZ,WAAQ,CAAC,KAAKlB,EAAL,CAAQb,YAAR,CAAqBqC,WAArB,GAAmC,KAAKD,eAAzC,KACH,KAAKtB,KAAL,GAAa,GADV,CAAR;AAEH;;AACDkB,EAAAA,cAAc,CAACF,IAAD,EAAO;AACjB,SAAKlB,QAAL,CAAc4B,QAAd,CAAuB,KAAKlB,OAA5B,EAAqC,KAAKN,QAA1C,EAAoD,KAAKyB,gBAAL,CAAsBX,IAAtB,CAApD;AACH;;AACDW,EAAAA,gBAAgB,CAACX,IAAD,EAAO;AACnB,QAAIY,MAAM,GAAI,GAAEZ,IAAK,IAArB;;AACA,QAAI,KAAKd,QAAL,KAAkB,WAAtB,EAAmC;AAC/B,cAAQ,KAAKC,aAAb;AACI,aAAK,aAAL;AACIyB,UAAAA,MAAM,GAAI,eAAc,KAAKC,MAAL,CAAYb,IAAZ,CAAkB,GAA1C;AACA;;AACJ,aAAK,OAAL;AACIY,UAAAA,MAAM,GAAI,SAAQZ,IAAK,GAAvB;AACA;;AACJ,aAAK,QAAL;AACIY,UAAAA,MAAM,GAAI,UAASZ,IAAK,MAAxB;AACA;AATR;AAWH;;AACD,YAAQ,KAAKd,QAAb;AACI,WAAK,SAAL;AACI0B,QAAAA,MAAM,GAAI,GAAEZ,IAAK,EAAjB;AACA;AAHR;;AAKA,WAAOY,MAAP;AACH;;AACDC,EAAAA,MAAM,CAACb,IAAD,EAAO;AACT,QAAIf,GAAG,GAAG,CAAC,CAAD,EAAIe,IAAJ,EAAU,CAAV,CAAV;;AACA,QAAI,KAAKf,GAAL,KAAa,GAAjB,EAAsB;AAClBA,MAAAA,GAAG,GAAG,CAACe,IAAD,EAAO,CAAP,EAAU,CAAV,CAAN;AACH,KAFD,MAGK,IAAI,KAAKf,GAAL,KAAa,GAAjB,EAAsB;AACvBA,MAAAA,GAAG,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAOe,IAAP,CAAN;AACH;;AACD,WAAQ,GAAEf,GAAG,CAAC,CAAD,CAAI,OAAMA,GAAG,CAAC,CAAD,CAAI,OAAMA,GAAG,CAAC,CAAD,CAAI,IAA3C;AACH;;AACDW,EAAAA,cAAc,CAACkB,QAAD,EAAW;AACrB,UAAMC,OAAO,GAAG;AACZC,MAAAA,UAAU,EAAE,KADA;AAEZC,MAAAA,SAAS,EAAEH,QAAQ,GAAG;AAFV,KAAhB;;AAIA,UAAMI,cAAc,GAAIC,KAAD,IAAWA,KAAK,CAACD,cAAN,IAAwBC,KAAK,CAACC,iBAAN,GAA0B,CAApF;;AACA,WAAO,IAAIC,oBAAJ,CAAyB,CAACC,OAAD,EAAU5B,QAAV,KAAuB;AACnD4B,MAAAA,OAAO,CAACC,OAAR,CAAiBJ,KAAD,IAAW;AACvB,YAAID,cAAc,CAACC,KAAD,CAAlB,EAA2B;AACvB,eAAKd,aAAL;AACH,SAFD,MAGK;AACD,eAAKI,eAAL;AACH;AACJ,OAPD;AAQH,KATM,EASJM,OATI,CAAP;AAUH;;AACDS,EAAAA,WAAW,GAAG;AACV,SAAKlC,iBAAL,CAAuBmC,IAAvB,CAA4B,KAA5B;AACA,SAAKnC,iBAAL,CAAuBoC,QAAvB;;AACA,QAAI,KAAK3C,EAAL,CAAQb,YAAZ,EAA0B;AACtB,WAAKwB,QAAL,CAAciC,UAAd;AACH;AACJ;;AAvGmB;;AAyGxB/C,iBAAiB,CAACP,IAAlB;AAAA,mBAA8GO,iBAA9G,EArHmG7B,EAqHnG,mBAAiJA,EAAE,CAAC6E,UAApJ,GArHmG7E,EAqHnG,mBAA2KA,EAAE,CAAC8E,SAA9K,GArHmG9E,EAqHnG,mBAAoMgB,gBAApM;AAAA;;AACAa,iBAAiB,CAACkD,IAAlB,kBAtHmG/E,EAsHnG;AAAA,QAAkG6B,iBAAlG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA,qDAvHmG7B,EAuHnG,mBAA2F6B,iBAA3F,EAA0H,CAAC;AAC/GL,IAAAA,IAAI,EAAEpB,SADyG;AAE/GqB,IAAAA,IAAI,EAAE,CAAC;AACCuD,MAAAA,QAAQ,EAAE;AADX,KAAD;AAFyG,GAAD,CAA1H,EAK4B,YAAY;AAAE,WAAO,CAAC;AAAExD,MAAAA,IAAI,EAAExB,EAAE,CAAC6E;AAAX,KAAD,EAA0B;AAAErD,MAAAA,IAAI,EAAExB,EAAE,CAAC8E;AAAX,KAA1B,EAAkD;AAAEtD,MAAAA,IAAI,EAAER;AAAR,KAAlD,CAAP;AAAuF,GALjI,EAKmJ;AAAEiB,IAAAA,KAAK,EAAE,CAAC;AAC7IT,MAAAA,IAAI,EAAEnB;AADuI,KAAD,CAAT;AAEnI6B,IAAAA,GAAG,EAAE,CAAC;AACNV,MAAAA,IAAI,EAAEnB;AADA,KAAD,CAF8H;AAInI8B,IAAAA,QAAQ,EAAE,CAAC;AACXX,MAAAA,IAAI,EAAEnB;AADK,KAAD,CAJyH;AAMnI+B,IAAAA,aAAa,EAAE,CAAC;AAChBZ,MAAAA,IAAI,EAAEnB;AADU,KAAD,CANoH;AAQnIgC,IAAAA,MAAM,EAAE,CAAC;AACTb,MAAAA,IAAI,EAAEnB;AADG,KAAD;AAR2H,GALnJ;AAAA;;AAiBA,MAAM4E,iBAAN,CAAwB;;AAExBA,iBAAiB,CAAC3D,IAAlB;AAAA,mBAA8G2D,iBAA9G;AAAA;;AACAA,iBAAiB,CAACC,IAAlB,kBA3ImGlF,EA2InG;AAAA,QAA+GiF;AAA/G;AACAA,iBAAiB,CAACE,IAAlB,kBA5ImGnF,EA4InG;AAAA,YAA4I,EAA5I;AAAA;;AACA;AAAA,qDA7ImGA,EA6InG,mBAA2FiF,iBAA3F,EAA0H,CAAC;AAC/GzD,IAAAA,IAAI,EAAElB,QADyG;AAE/GmB,IAAAA,IAAI,EAAE,CAAC;AACC2D,MAAAA,YAAY,EAAE,CAACvD,iBAAD,CADf;AAECwD,MAAAA,OAAO,EAAE,EAFV;AAGCC,MAAAA,OAAO,EAAE,CAACzD,iBAAD;AAHV,KAAD;AAFyG,GAAD,CAA1H;AAAA;AASA;AACA;AACA;;AAEA;AACA;AACA;;;AAEA,SAASoD,iBAAT,EAA4BpD,iBAA5B","sourcesContent":["import * as i0 from '@angular/core';\nimport { PLATFORM_ID, Injectable, Inject, Directive, Input, NgModule } from '@angular/core';\nimport { Subject, of, fromEvent } from 'rxjs';\nimport { takeUntil, filter, map, mergeMap, debounceTime } from 'rxjs/operators';\nimport { isPlatformBrowser } from '@angular/common';\n\nclass BrowserWindowRef {\n    constructor(platformId) {\n        this.platformId = platformId;\n    }\n    get nativeWindow() {\n        if (isPlatformBrowser(this.platformId)) {\n            return this.windowRef();\n        }\n        return false;\n    }\n    windowRef() {\n        // return the global native browser window object\n        return window;\n    }\n}\nBrowserWindowRef.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: BrowserWindowRef, deps: [{ token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });\nBrowserWindowRef.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: BrowserWindowRef, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: BrowserWindowRef, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () {\n        return [{ type: undefined, decorators: [{\n                        type: Inject,\n                        args: [PLATFORM_ID]\n                    }] }];\n    } });\n\nclass ParallaxDirective {\n    constructor(hostElement, renderer, wr) {\n        this.hostElement = hostElement;\n        this.renderer = renderer;\n        this.wr = wr;\n        this.speed = 30;\n        this.axe = 'y';\n        this.property = 'transform';\n        this.propertyValue = 'translate3d';\n        this.active = true;\n        this.inViewport = true;\n        this.componentDestroy$ = new Subject();\n    }\n    ngAfterViewInit() {\n        this.element = this.hostElement.nativeElement;\n        if (this.element && this.wr.nativeWindow && !this.observer) {\n            this.initParallax();\n        }\n    }\n    initParallax() {\n        this.observer = this.createObserver(0);\n        this.observer.observe(this.element);\n        const parallax$ = of('').pipe(takeUntil(this.componentDestroy$), filter(() => this.active && this.inViewport), map(() => {\n            const coef = this.calculateCoef();\n            this.renderParallax(coef);\n            return coef;\n        }));\n        this.windowScroll$ = fromEvent(this.wr.nativeWindow, 'scroll').pipe(mergeMap(() => parallax$));\n        this.windowResize$ = fromEvent(this.wr.nativeWindow, 'resize').pipe(debounceTime(500), mergeMap(() => parallax$));\n    }\n    startParallax() {\n        this.inViewport = true;\n        if (this.wr.nativeWindow && this.initialPosition === undefined) {\n            this.initialPosition = this.wr.nativeWindow.pageYOffset;\n            this.windowScroll$.subscribe();\n            this.windowResize$.subscribe();\n        }\n    }\n    destroyParallax() {\n        this.inViewport = false;\n    }\n    calculateCoef() {\n        return ((this.wr.nativeWindow.pageYOffset - this.initialPosition) *\n            (this.speed / 100));\n    }\n    renderParallax(coef) {\n        this.renderer.setStyle(this.element, this.property, this.getPropertyValue(coef));\n    }\n    getPropertyValue(coef) {\n        let result = `${coef}px`;\n        if (this.property === 'transform') {\n            switch (this.propertyValue) {\n                case 'translate3d':\n                    result = `translate3d(${this.getAxe(coef)})`;\n                    break;\n                case 'scale':\n                    result = `scale(${coef})`;\n                    break;\n                case 'rotate':\n                    result = `rotate(${coef}deg)`;\n                    break;\n            }\n        }\n        switch (this.property) {\n            case 'opacity':\n                result = `${coef}`;\n                break;\n        }\n        return result;\n    }\n    getAxe(coef) {\n        let axe = [0, coef, 0];\n        if (this.axe === 'x') {\n            axe = [coef, 0, 0];\n        }\n        else if (this.axe === 'z') {\n            axe = [0, 0, coef];\n        }\n        return `${axe[0]}px, ${axe[1]}px, ${axe[2]}px`;\n    }\n    createObserver(pourcent) {\n        const options = {\n            rootMargin: '0px',\n            threshold: pourcent / 100\n        };\n        const isIntersecting = (entry) => entry.isIntersecting || entry.intersectionRatio > 0;\n        return new IntersectionObserver((entries, observer) => {\n            entries.forEach((entry) => {\n                if (isIntersecting(entry)) {\n                    this.startParallax();\n                }\n                else {\n                    this.destroyParallax();\n                }\n            });\n        }, options);\n    }\n    ngOnDestroy() {\n        this.componentDestroy$.next(false);\n        this.componentDestroy$.complete();\n        if (this.wr.nativeWindow) {\n            this.observer.disconnect();\n        }\n    }\n}\nParallaxDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: ParallaxDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: BrowserWindowRef }], target: i0.ɵɵFactoryTarget.Directive });\nParallaxDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.3.9\", type: ParallaxDirective, selector: \"[ngx-parallax]\", inputs: { speed: \"speed\", axe: \"axe\", property: \"property\", propertyValue: \"propertyValue\", active: \"active\" }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: ParallaxDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngx-parallax]'\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: BrowserWindowRef }]; }, propDecorators: { speed: [{\n                type: Input\n            }], axe: [{\n                type: Input\n            }], property: [{\n                type: Input\n            }], propertyValue: [{\n                type: Input\n            }], active: [{\n                type: Input\n            }] } });\n\nclass NgxParallaxModule {\n}\nNgxParallaxModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: NgxParallaxModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxParallaxModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: NgxParallaxModule, declarations: [ParallaxDirective], exports: [ParallaxDirective] });\nNgxParallaxModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: NgxParallaxModule, imports: [[]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: NgxParallaxModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [ParallaxDirective],\n                    imports: [],\n                    exports: [ParallaxDirective]\n                }]\n        }] });\n\n/*\n * Public API Surface of ngx-parallax\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgxParallaxModule, ParallaxDirective };\n"]},"metadata":{},"sourceType":"module"}