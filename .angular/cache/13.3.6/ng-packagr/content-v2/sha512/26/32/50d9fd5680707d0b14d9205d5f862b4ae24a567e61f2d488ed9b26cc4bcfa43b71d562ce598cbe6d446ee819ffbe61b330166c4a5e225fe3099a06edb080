{"hash":"a05f2505d114b142f9efccd0b269172260410611","fesm2020":{"code":"import * as i0 from '@angular/core';\nimport { PLATFORM_ID, Injectable, Inject, Directive, Input, NgModule } from '@angular/core';\nimport { Subject, of, fromEvent } from 'rxjs';\nimport { takeUntil, filter, map, mergeMap, debounceTime } from 'rxjs/operators';\nimport { isPlatformBrowser } from '@angular/common';\n\nclass BrowserWindowRef {\n    constructor(platformId) {\n        this.platformId = platformId;\n    }\n    get nativeWindow() {\n        if (isPlatformBrowser(this.platformId)) {\n            return this.windowRef();\n        }\n        return false;\n    }\n    windowRef() {\n        // return the global native browser window object\n        return window;\n    }\n}\nBrowserWindowRef.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: BrowserWindowRef, deps: [{ token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });\nBrowserWindowRef.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: BrowserWindowRef, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: BrowserWindowRef, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }]; } });\n\nclass ParallaxDirective {\n    constructor(hostElement, renderer, wr) {\n        this.hostElement = hostElement;\n        this.renderer = renderer;\n        this.wr = wr;\n        this.speed = 30;\n        this.axe = 'y';\n        this.property = 'transform';\n        this.propertyValue = 'translate3d';\n        this.active = true;\n        this.inViewport = true;\n        this.componentDestroy$ = new Subject();\n    }\n    ngAfterViewInit() {\n        this.element = this.hostElement.nativeElement;\n        if (this.element && this.wr.nativeWindow && !this.observer) {\n            this.initParallax();\n        }\n    }\n    initParallax() {\n        this.observer = this.createObserver(0);\n        this.observer.observe(this.element);\n        const parallax$ = of('').pipe(takeUntil(this.componentDestroy$), filter(() => this.active && this.inViewport), map(() => {\n            const coef = this.calculateCoef();\n            this.renderParallax(coef);\n            return coef;\n        }));\n        this.windowScroll$ = fromEvent(this.wr.nativeWindow, 'scroll').pipe(mergeMap(() => parallax$));\n        this.windowResize$ = fromEvent(this.wr.nativeWindow, 'resize').pipe(debounceTime(500), mergeMap(() => parallax$));\n    }\n    startParallax() {\n        this.inViewport = true;\n        if (this.wr.nativeWindow && this.initialPosition === undefined) {\n            this.initialPosition = this.wr.nativeWindow.pageYOffset;\n            this.windowScroll$.subscribe();\n            this.windowResize$.subscribe();\n        }\n    }\n    destroyParallax() {\n        this.inViewport = false;\n    }\n    calculateCoef() {\n        return ((this.wr.nativeWindow.pageYOffset - this.initialPosition) *\n            (this.speed / 100));\n    }\n    renderParallax(coef) {\n        this.renderer.setStyle(this.element, this.property, this.getPropertyValue(coef));\n    }\n    getPropertyValue(coef) {\n        let result = `${coef}px`;\n        if (this.property === 'transform') {\n            switch (this.propertyValue) {\n                case 'translate3d':\n                    result = `translate3d(${this.getAxe(coef)})`;\n                    break;\n                case 'scale':\n                    result = `scale(${coef})`;\n                    break;\n                case 'rotate':\n                    result = `rotate(${coef}deg)`;\n                    break;\n            }\n        }\n        switch (this.property) {\n            case 'opacity':\n                result = `${coef}`;\n                break;\n        }\n        return result;\n    }\n    getAxe(coef) {\n        let axe = [0, coef, 0];\n        if (this.axe === 'x') {\n            axe = [coef, 0, 0];\n        }\n        else if (this.axe === 'z') {\n            axe = [0, 0, coef];\n        }\n        return `${axe[0]}px, ${axe[1]}px, ${axe[2]}px`;\n    }\n    createObserver(pourcent) {\n        const options = {\n            rootMargin: '0px',\n            threshold: pourcent / 100\n        };\n        const isIntersecting = (entry) => entry.isIntersecting || entry.intersectionRatio > 0;\n        return new IntersectionObserver((entries, observer) => {\n            entries.forEach((entry) => {\n                if (isIntersecting(entry)) {\n                    this.startParallax();\n                }\n                else {\n                    this.destroyParallax();\n                }\n            });\n        }, options);\n    }\n    ngOnDestroy() {\n        this.componentDestroy$.next(false);\n        this.componentDestroy$.complete();\n        if (this.wr.nativeWindow) {\n            this.observer.disconnect();\n        }\n    }\n}\nParallaxDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: ParallaxDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: BrowserWindowRef }], target: i0.ɵɵFactoryTarget.Directive });\nParallaxDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.3.9\", type: ParallaxDirective, selector: \"[ngx-parallax]\", inputs: { speed: \"speed\", axe: \"axe\", property: \"property\", propertyValue: \"propertyValue\", active: \"active\" }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: ParallaxDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngx-parallax]'\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: BrowserWindowRef }]; }, propDecorators: { speed: [{\n                type: Input\n            }], axe: [{\n                type: Input\n            }], property: [{\n                type: Input\n            }], propertyValue: [{\n                type: Input\n            }], active: [{\n                type: Input\n            }] } });\n\nclass NgxParallaxModule {\n}\nNgxParallaxModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: NgxParallaxModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxParallaxModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: NgxParallaxModule, declarations: [ParallaxDirective], exports: [ParallaxDirective] });\nNgxParallaxModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: NgxParallaxModule, imports: [[]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: NgxParallaxModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [ParallaxDirective],\n                    imports: [],\n                    exports: [ParallaxDirective]\n                }]\n        }] });\n\n/*\n * Public API Surface of ngx-parallax\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgxParallaxModule, ParallaxDirective };\n//# sourceMappingURL=yoozly-ngx-parallax.mjs.map\n","map":{"version":3,"file":"yoozly-ngx-parallax.mjs","sources":["../../../projects/ngx-parallax/src/lib/services/windowref.service.ts","../../../projects/ngx-parallax/src/lib/ngx-parallax.directive.ts","../../../projects/ngx-parallax/src/lib/ngx-parallax.module.ts","../../../projects/ngx-parallax/src/public_api.ts","../../../projects/ngx-parallax/src/yoozly-ngx-parallax.ts"],"sourcesContent":["import { Injectable, PLATFORM_ID, Inject } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\n\n@Injectable({ providedIn: 'root' })\nexport class BrowserWindowRef {\n  constructor(@Inject(PLATFORM_ID) private platformId) {}\n\n  get nativeWindow(): any {\n    if (isPlatformBrowser(this.platformId)) {\n      return this.windowRef();\n    }\n    return false;\n  }\n\n  private windowRef(): Window {\n    // return the global native browser window object\n    return window;\n  }\n}\n","import {\n  Directive,\n  Input,\n  ElementRef,\n  Renderer2,\n  OnDestroy,\n  AfterViewInit\n} from '@angular/core';\nimport { fromEvent, Observable, of, Subject } from 'rxjs';\nimport { takeUntil, filter, map, debounceTime, mergeMap } from 'rxjs/operators';\n\nimport { BrowserWindowRef } from './services/windowref.service';\n\n@Directive({\n  selector: '[ngx-parallax]'\n})\nexport class ParallaxDirective implements OnDestroy, AfterViewInit {\n  @Input() speed = 30;\n  @Input() axe = 'y';\n  @Input() property = 'transform';\n  @Input() propertyValue = 'translate3d';\n  @Input() active = true;\n\n  private inViewport = true;\n  private observer: IntersectionObserver;\n  private element: HTMLElement;\n  private initialPosition: number;\n  private componentDestroy$ = new Subject<boolean>();\n  private windowScroll$: Observable<number>;\n  private windowResize$: Observable<number>;\n\n  constructor(\n    private hostElement: ElementRef,\n    private renderer: Renderer2,\n    private wr: BrowserWindowRef\n  ) {}\n\n  ngAfterViewInit() {\n    this.element = this.hostElement.nativeElement;\n\n    if (this.element && this.wr.nativeWindow && !this.observer) {\n      this.initParallax();\n    }\n  }\n\n  private initParallax(): void {\n    this.observer = this.createObserver(0);\n    this.observer.observe(this.element);\n\n    const parallax$ = of('').pipe(\n      takeUntil(this.componentDestroy$),\n      filter(() => this.active && this.inViewport),\n      map(() => {\n        const coef = this.calculateCoef();\n        this.renderParallax(coef);\n        return coef;\n      })\n    );\n\n    this.windowScroll$ = fromEvent(this.wr.nativeWindow, 'scroll').pipe(\n      mergeMap(() => parallax$)\n    );\n\n    this.windowResize$ = fromEvent(this.wr.nativeWindow, 'resize').pipe(\n      debounceTime(500),\n      mergeMap(() => parallax$)\n    );\n  }\n\n  private startParallax(): void {\n    this.inViewport = true;\n\n    if (this.wr.nativeWindow && this.initialPosition === undefined) {\n      this.initialPosition = this.wr.nativeWindow.pageYOffset;\n      this.windowScroll$.subscribe();\n      this.windowResize$.subscribe();\n    }\n  }\n\n  private destroyParallax(): void {\n    this.inViewport = false;\n  }\n\n  private calculateCoef(): number {\n    return (\n      (this.wr.nativeWindow.pageYOffset - this.initialPosition) *\n      (this.speed / 100)\n    );\n  }\n\n  private renderParallax(coef: number): void {\n    this.renderer.setStyle(\n      this.element,\n      this.property,\n      this.getPropertyValue(coef)\n    );\n  }\n\n  private getPropertyValue(coef: number): string {\n    let result = `${coef}px`;\n\n    if (this.property === 'transform') {\n      switch (this.propertyValue) {\n        case 'translate3d':\n          result = `translate3d(${this.getAxe(coef)})`;\n          break;\n        case 'scale':\n          result = `scale(${coef})`;\n          break;\n        case 'rotate':\n          result = `rotate(${coef}deg)`;\n          break;\n      }\n    }\n\n    switch (this.property) {\n      case 'opacity':\n        result = `${coef}`;\n        break;\n    }\n\n    return result;\n  }\n\n  private getAxe(coef: number): string {\n    let axe = [0, coef, 0];\n\n    if (this.axe === 'x') {\n      axe = [coef, 0, 0];\n    } else if (this.axe === 'z') {\n      axe = [0, 0, coef];\n    }\n\n    return `${axe[0]}px, ${axe[1]}px, ${axe[2]}px`;\n  }\n\n  private createObserver(pourcent: number) {\n    const options = {\n      rootMargin: '0px',\n      threshold: pourcent / 100\n    };\n\n    const isIntersecting = (entry: IntersectionObserverEntry) =>\n      entry.isIntersecting || entry.intersectionRatio > 0;\n\n    return new IntersectionObserver((entries, observer) => {\n      entries.forEach((entry) => {\n        if (isIntersecting(entry)) {\n          this.startParallax();\n        } else {\n          this.destroyParallax();\n        }\n      });\n    }, options);\n  }\n\n  ngOnDestroy() {\n    this.componentDestroy$.next(false);\n    this.componentDestroy$.complete();\n    if (this.wr.nativeWindow) {\n      this.observer.disconnect();\n    }\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { ParallaxDirective } from './ngx-parallax.directive';\n\n@NgModule({\n  declarations: [ParallaxDirective],\n  imports: [],\n  exports: [ParallaxDirective]\n})\nexport class NgxParallaxModule {}\n","/*\n * Public API Surface of ngx-parallax\n */\n\nexport * from './lib/ngx-parallax.module';\nexport * from './lib/ngx-parallax.directive';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n"],"names":["i1.BrowserWindowRef"],"mappings":"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"}},"fesm2015":{"code":"import * as i0 from '@angular/core';\nimport { PLATFORM_ID, Injectable, Inject, Directive, Input, NgModule } from '@angular/core';\nimport { Subject, of, fromEvent } from 'rxjs';\nimport { takeUntil, filter, map, mergeMap, debounceTime } from 'rxjs/operators';\nimport { isPlatformBrowser } from '@angular/common';\n\nclass BrowserWindowRef {\n    constructor(platformId) {\n        this.platformId = platformId;\n    }\n    get nativeWindow() {\n        if (isPlatformBrowser(this.platformId)) {\n            return this.windowRef();\n        }\n        return false;\n    }\n    windowRef() {\n        // return the global native browser window object\n        return window;\n    }\n}\nBrowserWindowRef.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: BrowserWindowRef, deps: [{ token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });\nBrowserWindowRef.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: BrowserWindowRef, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: BrowserWindowRef, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () {\n        return [{ type: undefined, decorators: [{\n                        type: Inject,\n                        args: [PLATFORM_ID]\n                    }] }];\n    } });\n\nclass ParallaxDirective {\n    constructor(hostElement, renderer, wr) {\n        this.hostElement = hostElement;\n        this.renderer = renderer;\n        this.wr = wr;\n        this.speed = 30;\n        this.axe = 'y';\n        this.property = 'transform';\n        this.propertyValue = 'translate3d';\n        this.active = true;\n        this.inViewport = true;\n        this.componentDestroy$ = new Subject();\n    }\n    ngAfterViewInit() {\n        this.element = this.hostElement.nativeElement;\n        if (this.element && this.wr.nativeWindow && !this.observer) {\n            this.initParallax();\n        }\n    }\n    initParallax() {\n        this.observer = this.createObserver(0);\n        this.observer.observe(this.element);\n        const parallax$ = of('').pipe(takeUntil(this.componentDestroy$), filter(() => this.active && this.inViewport), map(() => {\n            const coef = this.calculateCoef();\n            this.renderParallax(coef);\n            return coef;\n        }));\n        this.windowScroll$ = fromEvent(this.wr.nativeWindow, 'scroll').pipe(mergeMap(() => parallax$));\n        this.windowResize$ = fromEvent(this.wr.nativeWindow, 'resize').pipe(debounceTime(500), mergeMap(() => parallax$));\n    }\n    startParallax() {\n        this.inViewport = true;\n        if (this.wr.nativeWindow && this.initialPosition === undefined) {\n            this.initialPosition = this.wr.nativeWindow.pageYOffset;\n            this.windowScroll$.subscribe();\n            this.windowResize$.subscribe();\n        }\n    }\n    destroyParallax() {\n        this.inViewport = false;\n    }\n    calculateCoef() {\n        return ((this.wr.nativeWindow.pageYOffset - this.initialPosition) *\n            (this.speed / 100));\n    }\n    renderParallax(coef) {\n        this.renderer.setStyle(this.element, this.property, this.getPropertyValue(coef));\n    }\n    getPropertyValue(coef) {\n        let result = `${coef}px`;\n        if (this.property === 'transform') {\n            switch (this.propertyValue) {\n                case 'translate3d':\n                    result = `translate3d(${this.getAxe(coef)})`;\n                    break;\n                case 'scale':\n                    result = `scale(${coef})`;\n                    break;\n                case 'rotate':\n                    result = `rotate(${coef}deg)`;\n                    break;\n            }\n        }\n        switch (this.property) {\n            case 'opacity':\n                result = `${coef}`;\n                break;\n        }\n        return result;\n    }\n    getAxe(coef) {\n        let axe = [0, coef, 0];\n        if (this.axe === 'x') {\n            axe = [coef, 0, 0];\n        }\n        else if (this.axe === 'z') {\n            axe = [0, 0, coef];\n        }\n        return `${axe[0]}px, ${axe[1]}px, ${axe[2]}px`;\n    }\n    createObserver(pourcent) {\n        const options = {\n            rootMargin: '0px',\n            threshold: pourcent / 100\n        };\n        const isIntersecting = (entry) => entry.isIntersecting || entry.intersectionRatio > 0;\n        return new IntersectionObserver((entries, observer) => {\n            entries.forEach((entry) => {\n                if (isIntersecting(entry)) {\n                    this.startParallax();\n                }\n                else {\n                    this.destroyParallax();\n                }\n            });\n        }, options);\n    }\n    ngOnDestroy() {\n        this.componentDestroy$.next(false);\n        this.componentDestroy$.complete();\n        if (this.wr.nativeWindow) {\n            this.observer.disconnect();\n        }\n    }\n}\nParallaxDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: ParallaxDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: BrowserWindowRef }], target: i0.ɵɵFactoryTarget.Directive });\nParallaxDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.3.9\", type: ParallaxDirective, selector: \"[ngx-parallax]\", inputs: { speed: \"speed\", axe: \"axe\", property: \"property\", propertyValue: \"propertyValue\", active: \"active\" }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: ParallaxDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[ngx-parallax]'\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: BrowserWindowRef }]; }, propDecorators: { speed: [{\n                type: Input\n            }], axe: [{\n                type: Input\n            }], property: [{\n                type: Input\n            }], propertyValue: [{\n                type: Input\n            }], active: [{\n                type: Input\n            }] } });\n\nclass NgxParallaxModule {\n}\nNgxParallaxModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: NgxParallaxModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxParallaxModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: NgxParallaxModule, declarations: [ParallaxDirective], exports: [ParallaxDirective] });\nNgxParallaxModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: NgxParallaxModule, imports: [[]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.9\", ngImport: i0, type: NgxParallaxModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [ParallaxDirective],\n                    imports: [],\n                    exports: [ParallaxDirective]\n                }]\n        }] });\n\n/*\n * Public API Surface of ngx-parallax\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgxParallaxModule, ParallaxDirective };\n//# sourceMappingURL=yoozly-ngx-parallax.mjs.map\n","map":{"version":3,"file":"yoozly-ngx-parallax.mjs","sources":["../../../projects/ngx-parallax/src/lib/services/windowref.service.ts","../../../projects/ngx-parallax/src/lib/ngx-parallax.directive.ts","../../../projects/ngx-parallax/src/lib/ngx-parallax.module.ts","../../../projects/ngx-parallax/src/public_api.ts","../../../projects/ngx-parallax/src/yoozly-ngx-parallax.ts"],"sourcesContent":["import { Injectable, PLATFORM_ID, Inject } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\n\n@Injectable({ providedIn: 'root' })\nexport class BrowserWindowRef {\n  constructor(@Inject(PLATFORM_ID) private platformId) {}\n\n  get nativeWindow(): any {\n    if (isPlatformBrowser(this.platformId)) {\n      return this.windowRef();\n    }\n    return false;\n  }\n\n  private windowRef(): Window {\n    // return the global native browser window object\n    return window;\n  }\n}\n","import {\n  Directive,\n  Input,\n  ElementRef,\n  Renderer2,\n  OnDestroy,\n  AfterViewInit\n} from '@angular/core';\nimport { fromEvent, Observable, of, Subject } from 'rxjs';\nimport { takeUntil, filter, map, debounceTime, mergeMap } from 'rxjs/operators';\n\nimport { BrowserWindowRef } from './services/windowref.service';\n\n@Directive({\n  selector: '[ngx-parallax]'\n})\nexport class ParallaxDirective implements OnDestroy, AfterViewInit {\n  @Input() speed = 30;\n  @Input() axe = 'y';\n  @Input() property = 'transform';\n  @Input() propertyValue = 'translate3d';\n  @Input() active = true;\n\n  private inViewport = true;\n  private observer: IntersectionObserver;\n  private element: HTMLElement;\n  private initialPosition: number;\n  private componentDestroy$ = new Subject<boolean>();\n  private windowScroll$: Observable<number>;\n  private windowResize$: Observable<number>;\n\n  constructor(\n    private hostElement: ElementRef,\n    private renderer: Renderer2,\n    private wr: BrowserWindowRef\n  ) {}\n\n  ngAfterViewInit() {\n    this.element = this.hostElement.nativeElement;\n\n    if (this.element && this.wr.nativeWindow && !this.observer) {\n      this.initParallax();\n    }\n  }\n\n  private initParallax(): void {\n    this.observer = this.createObserver(0);\n    this.observer.observe(this.element);\n\n    const parallax$ = of('').pipe(\n      takeUntil(this.componentDestroy$),\n      filter(() => this.active && this.inViewport),\n      map(() => {\n        const coef = this.calculateCoef();\n        this.renderParallax(coef);\n        return coef;\n      })\n    );\n\n    this.windowScroll$ = fromEvent(this.wr.nativeWindow, 'scroll').pipe(\n      mergeMap(() => parallax$)\n    );\n\n    this.windowResize$ = fromEvent(this.wr.nativeWindow, 'resize').pipe(\n      debounceTime(500),\n      mergeMap(() => parallax$)\n    );\n  }\n\n  private startParallax(): void {\n    this.inViewport = true;\n\n    if (this.wr.nativeWindow && this.initialPosition === undefined) {\n      this.initialPosition = this.wr.nativeWindow.pageYOffset;\n      this.windowScroll$.subscribe();\n      this.windowResize$.subscribe();\n    }\n  }\n\n  private destroyParallax(): void {\n    this.inViewport = false;\n  }\n\n  private calculateCoef(): number {\n    return (\n      (this.wr.nativeWindow.pageYOffset - this.initialPosition) *\n      (this.speed / 100)\n    );\n  }\n\n  private renderParallax(coef: number): void {\n    this.renderer.setStyle(\n      this.element,\n      this.property,\n      this.getPropertyValue(coef)\n    );\n  }\n\n  private getPropertyValue(coef: number): string {\n    let result = `${coef}px`;\n\n    if (this.property === 'transform') {\n      switch (this.propertyValue) {\n        case 'translate3d':\n          result = `translate3d(${this.getAxe(coef)})`;\n          break;\n        case 'scale':\n          result = `scale(${coef})`;\n          break;\n        case 'rotate':\n          result = `rotate(${coef}deg)`;\n          break;\n      }\n    }\n\n    switch (this.property) {\n      case 'opacity':\n        result = `${coef}`;\n        break;\n    }\n\n    return result;\n  }\n\n  private getAxe(coef: number): string {\n    let axe = [0, coef, 0];\n\n    if (this.axe === 'x') {\n      axe = [coef, 0, 0];\n    } else if (this.axe === 'z') {\n      axe = [0, 0, coef];\n    }\n\n    return `${axe[0]}px, ${axe[1]}px, ${axe[2]}px`;\n  }\n\n  private createObserver(pourcent: number) {\n    const options = {\n      rootMargin: '0px',\n      threshold: pourcent / 100\n    };\n\n    const isIntersecting = (entry: IntersectionObserverEntry) =>\n      entry.isIntersecting || entry.intersectionRatio > 0;\n\n    return new IntersectionObserver((entries, observer) => {\n      entries.forEach((entry) => {\n        if (isIntersecting(entry)) {\n          this.startParallax();\n        } else {\n          this.destroyParallax();\n        }\n      });\n    }, options);\n  }\n\n  ngOnDestroy() {\n    this.componentDestroy$.next(false);\n    this.componentDestroy$.complete();\n    if (this.wr.nativeWindow) {\n      this.observer.disconnect();\n    }\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { ParallaxDirective } from './ngx-parallax.directive';\n\n@NgModule({\n  declarations: [ParallaxDirective],\n  imports: [],\n  exports: [ParallaxDirective]\n})\nexport class NgxParallaxModule {}\n","/*\n * Public API Surface of ngx-parallax\n */\n\nexport * from './lib/ngx-parallax.module';\nexport * from './lib/ngx-parallax.directive';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n"],"names":["i1.BrowserWindowRef"],"mappings":"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"}}}